# == Schema Information
#
# Table name: ref_categories
#
#  id                          :integer          not null, primary key
#  site_id                     :integer
#  genre                       :string(255)
#  name                        :string(255)
#  stream_url                  :text
#  created_at                  :datetime         not null
#  updated_at                  :datetime         not null
#  stream_id                   :integer
#  is_disabled                 :boolean
#  created_by                  :integer
#  updated_by                  :integer
#  count                       :integer          default(0)
#  name_html                   :text
#  slug                        :string(255)
#  english_name                :string(255)
#  vertical_page_url           :text
#  description                 :text
#  keywords                    :text
#  show_by_publisher_in_header :boolean          default(TRUE)
#  g_a_tracking_id             :string
#

class RefCategory < ApplicationRecord
    #CONSTANTS
    #CUSTOM TABLES
    #GEMS
    before_validation :before_validation_set
    extend FriendlyId
    friendly_id :english_name, use: :slugged
    #CONCERNS
    include Propagatable
    include AssociableBySi
    #ASSOCIATIONS
    has_one :stream, foreign_key: 'id', primary_key: 'stream_id'
    has_many :navigations, class_name: "SiteVerticalNavigation", foreign_key: "ref_category_vertical_id", dependent: :destroy
    has_one :folder, foreign_key: 'ref_category_vertical_id'
    has_many :folders, foreign_key: 'ref_category_vertical_id'
    has_many :pages, foreign_key: 'ref_category_series_id'
    has_many :feeds, dependent: :destroy

    has_many :stories_with_intersection, foreign_key: "ref_category_intersection_id", class_name: "Page"
    has_many :stories_with_sub_intersection, foreign_key: "ref_category_sub_intersection_id", class_name: "Page"

    #ACCESSORS
    #VALIDATIONS
    validates :name, presence: true, uniqueness: {scope: [:site, :genre]}, length: { in: 3..15 }
    validates :genre, inclusion: {in: ["intersection", "sub intersection", "series"]}

    #CALLBACKS
    before_create :before_create_set

    after_create :after_create_set
    before_update :before_update_set
    after_destroy :update_site_verticals
    after_update :update_page_seo_content
    after_update :update_site_verticals
    #SCOPE
    #OTHER

    def should_generate_new_friendly_id?
        self.slug.nil? || english_name_changed?
    end

    def vertical_page
        self.pages.where(template_page_id: TemplatePage.where(name: "Homepage: Vertical").first.id).first
    end

    # def vertical_page_url
    #     "#{self.site.cdn_endpoint}/#{self.slug}.html"
    # end

    #TODO AMIT / AB2: I am temporarily changing is_autogenerated: to TRUE
    def view_casts
        if genre == "series"
            ViewCast.where(template_card_id: TemplateCard.where(name: "toStory").pluck(:id)).where(ref_category_vertical_id: self.id)
        elsif genre == "intersection"
            ViewCast.where(template_card_id: TemplateCard.where(name: "toStory").pluck(:id)).where(ref_category_intersection_id: self.id)
        else
            ViewCast.where(template_card_id: TemplateCard.where(name: "toStory").pluck(:id)).where(ref_category_sub_intersection_id: self.id)
        end
    end

    def cards_as_json
        view_casts = site.view_casts.select(:name, :id, :folder_id, :template_card_id, :datacast_identifier, :site_id).includes(:folder, :template_card).where.not(template_card_id: TemplateCard.where(name: ["toCoverImage", "toCoverStory", "Footer", "Header", "toParagraph"]).pluck(:id)).where.not(folder_id: site.folders.where(is_trash: true).pluck(:id)).order([updated_at: :desc, created_at: :desc])
        json_data = []

        view_casts.each do |d|
            obj = {}
            obj["folder_name"] = d.folder.name
            obj['template_card_name'] = d.template_card.name
            obj['template_card_id'] = d.template_card_id
            obj['id'] = d.id
            obj["datacast_identifier"] = d.datacast_identifier
            obj["name"] = d.name
            obj['iframe_url'] = d.template_card.index_html + "?view_cast_id=#{d.datacast_identifier}" + "&base_url= #{d.site.cdn_endpoint}"

            json_data << obj
        end

        json_data
    end

    def vertical_header_key
        "#{self.slug}/navigation.json"
    end

    def vertical_header_url
        "#{self.site.cdn_endpoint}/#{vertical_header_key}"
    end

    def update_site_verticals
        Thread.new do
            verticals_json = []
            self.site.verticals.each do |ver|
                next unless ver.vertical_page.present? and ver.vertical_page.is_published
                verticals_json << {"name": "#{ver.name}","url": "#{ver.vertical_page_url}","new_window": true, "name_html": "#{ver.name_html}", "show_by_publisher_in_header": ver.show_by_publisher_in_header }
            end
            key = "#{self.site.homepage_header_key}"
            encoded_file = Base64.encode64(verticals_json.to_json)
            content_type = "application/json"
            resp = Api::ProtoGraph::Utility.upload_to_cdn(encoded_file, key, content_type, self.site.cdn_bucket)
            Api::ProtoGraph::CloudFront.invalidate(self.site, ["/#{key}"], 1)
            ActiveRecord::Base.connection.close
        end
    end

    def update_page_seo_content
        if (["keywords", "description"] & self.saved_changes.transform_values(&:first).keys).length > 0
            self.vertical_page.update_columns(meta_description: description, meta_keywords: keywords)
        end
    end

    def before_validation_set
        self.english_name = self.name if self.site.is_english
    end

    class << self

        def find_or_create(genre, site_id, name, created_by, updated_by)
            rc = where(genre: genre, name: name).first
            if rc.blank?
                rc = create({genre: genre, name: name, site_id: site_id, created_by: created_by, updated_by: updated_by, english_name: name})
            end
            rc
        end

    end

    #PRIVATE
    private

    def before_create_set
        self.vertical_page_url = "#{self.site.cdn_endpoint}/#{self.slug}.html" if self.vertical_page_url.blank?
        true
    end

    def before_update_set
        self.is_disabled = true if self.count > 0
        self.english_name = ActionView::Base.full_sanitizer.sanitize(self.english_name)
        self.name_html = self.name if self.name_html.blank?
        true
    end

    def after_create_set
        s = Stream.create!({
            is_automated_stream: true,
            col_name: "RefCategory",
            col_id: self.id,
            title: self.name,
            description: "#{self.name} stream",
            site_id: self.site_id,
            limit: 50
        })

        self.update_columns(stream_url: "#{s.site.cdn_endpoint}/#{s.cdn_key}", stream_id: s.id)

        # Create a new page object
        if self.genre == "series"
            page = Page.create({
                site_id: self.site_id,
                headline: "#{self.name + " "*(50 - (self.name.length)) }",
                template_page_id: TemplatePage.where(name: 'Homepage: Vertical').first.id,
                ref_category_series_id: self.id,
                created_by: self.created_by,
                updated_by: self.updated_by,
                datacast_identifier: "",
                url: "#{vertical_page_url}",
                meta_description: "#{description}",
                meta_keywords: "#{keywords}"
            })
            page.push_json_to_s3
            #Update the site vertical json
            update_site_verticals
            key = self.vertical_header_key
            encoded_file = Base64.encode64({"Header"=>[], "Footer"=>[]}.to_json)
            content_type = "application/json"
            resp = Api::ProtoGraph::Utility.upload_to_cdn(encoded_file, key, content_type, self.site.cdn_bucket)
        end
    end

end
